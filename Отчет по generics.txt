 ак € пон€л <T> и <?> можно отдаленно сравнить с примитивными типами и классами-оболочками дл€ них.
» <T> и <?> указывают компил€тору на то, чтобы он игнорировал тип, он будет указан при создании объекта, но 
<T> все же более строгий, и его можно использовать когда мы знаем с какими типами в дальнейшем будем работать.
ј <?> позвол€ет избежать ошибок с разными типами.
ѕримеры: 
ƒопустим у нас есть такой класс с методом сравнени€
class ArrayList<T> {	
	public void compare(ArrayList<T> numbers){
	    //реализаци€
	}
	
}

public class Text {
	
	public static void main(String[] args){
			
		ArrayList<Number> arrayList = new ArrayList<Number>();
		ArrayList<Integer> arrayList1 = new ArrayList<Integer>();
		
		arrayList1.compare(arrayList);	
}
} 
«десь мы словим ошибку, так мы обьекту с типом Integer вызываем метод в который передаем обект с другим типом -Number
так же будет и в обратную сторону arrayList.compare(arrayList1); - выдаст ошибку

но если в нашем методе указать 
class ArrayList<T> {	
	public void compare(ArrayList<?> numbers){
	    //реализаци€
	}
	
}

то все работает. “ак же <?> - можно задавать ограничени€ какого типа обьекты можно передавать( по умолчанию как € пон€л Object
и все наследники, те любой), но если указать например <? exteds Integer> мы сможем передавать туда только классы Integer и наследников,
класс Number уже не сможем.

ƒл€ статических методов, как € пон€л не играет роли <T> или <?> кроме синтаксиса.
public static  <T> double sum(ArrayList<T> numbers){
	    return 0;
	}

нужно добавл€ть <T>
и 
public static double sum(ArrayList<?> numbers){
	    return 0;
	}
€ пон€л что св€зано это с тем, что статический метод не прив€зан ни к какому обьекту, и не может получить тип от него,
поэтому должен определить его в момент своего вывода.